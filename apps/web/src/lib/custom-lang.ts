type ParameterTypes =
  | "Text"
  | "Decimal"
  | "Integer"
  | "Date"
  | "DateTime"
  | "Boolean"
  | "GenericType";

const defaultValue: Record<ParameterTypes, string> = {
  Text: '""',
  Decimal: "0",
  Integer: "0",
  Date: "#1900-01-01#",
  DateTime: "#1900-01-01 00:00:00#",
  Boolean: "False",
  GenericType: "",
};

export type CustomLanguageFunction = {
  label: string;
  description?: string | Array<string>;
  parameters?: Array<{
    name: string;
    type: ParameterTypes;
    description?: string;
    mandatory?: boolean;
  }>;
  jsParser: (params: Array<string>) => string;
  returnType: ParameterTypes;
  examples?: Array<string>;
};

export type CustomLanguage = {
  id: string;
  functions?: Array<CustomLanguageFunction>;
  keywords?: Array<{
    label: string;
    insertText: string;
  }>;
  lineComment?: string;
};

export function isValidParameter(text: string): boolean {
  text = text;
  return true;
}

export function transpileCustomCodeToJavascript(
  lang: CustomLanguage,
  snippet: string
): string {
  let js = `return (${replaceFunctionsRecursive(
    snippet,
    lang.functions || []
  )})`;

  if (["DateTime", "Date"].some((it) => snippet.includes(it))) {
    js = `Date.prototype.toString = function() {return '#' + this.toISOString().split("T").join(" ").split(".")[0] + '#';};\r\n${js}`;
  }

  return js;
}

// Transpile generated with ChatGPT
// All code bellow was generated by an AI

function replaceFunctionsRecursive(
  input: string,
  functions: CustomLanguageFunction[]
) {
  // Map by function name for quick lookup
  const funcMap = new Map(functions.map((f) => [f.label.toLowerCase(), f]));

  // Parser loop
  function parseExpression(expr: string) {
    let result = "";
    let i = 0;

    while (i < expr.length) {
      const match = /^[a-zA-Z_]\w*/.exec(expr.slice(i));
      if (match) {
        const funcName = match[0];
        const func = funcMap.get(funcName.toLowerCase());

        // const start = i;
        i += funcName.length;

        if (func && expr[i] === "(") {
          // Parse the parameters recursively
          const { args, end } = extractArgs(expr, i);
          const parsedArgs = args.map(parseExpression);
          result += func.jsParser(
            (func.parameters || []).map(
              (param, i) =>
                parsedArgs[i] ||
                (param.mandatory ? defaultValue[param.type] : "")
            )
          );
          i = end + 1; // skip past ')'
        } else {
          result += funcName;
        }
      } else {
        result += expr[i];
        i++;
      }
    }

    return result;
  }

  // Extract arguments from a function call, respecting nested parentheses
  function extractArgs(str: string, startIndex: number) {
    let args = [];
    let current = "";
    let depth = 0;
    let i = startIndex + 1;

    while (i < str.length) {
      const char = str[i];

      if (char === "(") {
        depth++;
        current += char;
      } else if (char === ")") {
        if (depth === 0) {
          if (current.trim()) args.push(current.trim());
          break;
        } else {
          depth--;
          current += char;
        }
      } else if (char === "," && depth === 0) {
        args.push(current.trim());
        current = "";
      } else {
        current += char;
      }

      i++;
    }

    return { args, end: i };
  }

  return parseExpression(input);
}
