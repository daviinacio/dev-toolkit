type ParameterTypes =
  | "Text"
  | "Decimal"
  | "Integer"
  | "Date"
  | "DateTime"
  | "Boolean"
  | "GenericType"
  | "Currency";

const defaultValue: Record<ParameterTypes, string> = {
  Text: '""',
  Decimal: "0",
  Integer: "0",
  Date: "#1900-01-01#",
  DateTime: "#1900-01-01 00:00:00#",
  Boolean: "False",
  GenericType: "",
  Currency: "0",
};

export type CustomLanguageFunction = {
  label: string;
  description?: string | Array<string>;
  parameters?: Array<{
    name: string;
    type: ParameterTypes;
    description?: string;
    mandatory?: boolean;
    defaultValue?: string;
  }>;
  jsParser: (params: Array<string>) => string;
  returnType: ParameterTypes;
  examples?: Array<string>;
};

export type CustomLanguage = {
  id: string;
  functions?: Array<CustomLanguageFunction>;
  keywords?: Array<{
    label: string;
    insertText: string;
  }>;
  lineComment?: string;
};

export function isValidParameter(text: string): boolean {
  text = text;
  return true;
}

export function transpileCustomCodeToJavascript(
  lang: CustomLanguage,
  snippet: string
): string {
  let js = `return (${replaceFunctionsRecursive(
    snippet,
    lang.functions || []
  )})`;

  if (["DateTime", "Date"].some((it) => snippet.includes(it))) {
    js = `Date.prototype.toString = function() {return '#' + this.toISOString().split("T").join(" ").split(".")[0] + '#';};\r\n${js}`;
  }

  return js;
}

// Transpile generated with ChatGPT
// All code bellow was generated by an AI

function replaceFunctionsRecursive(
  input: string,
  functions: CustomLanguageFunction[]
) {
  // Map by function name for quick lookup
  const funcMap = new Map(functions.map((f) => [f.label.toLowerCase(), f]));

  // Main entry: walks the expression and replaces any known function calls
  function parseExpression(expr: string): string {
    let result = "";
    let i = 0;

    while (i < expr.length) {
      const match = /^[a-zA-Z_]\w*/.exec(expr.slice(i));
      if (match) {
        const funcName = match[0];
        const func = funcMap.get(funcName.toLowerCase());
        i += funcName.length;

        if (func && expr[i] === "(") {
          // We've found a known function call: extract its arguments
          const { args, end } = extractArgs(expr, i);
          // Recursively parse each argument (to handle nested calls)
          const parsedArgs = args.map(parseExpression);
          // Build the replacement via jsParser, filling defaults if needed
          const finalArgs = (func.parameters || []).map((paramDef, idx) =>
            parsedArgs[idx] != null
              ? parsedArgs[idx]
              : paramDef.mandatory
              ? paramDef.defaultValue || defaultValue[paramDef.type]
              : ""
          );
          result += func.jsParser(finalArgs);
          i = end + 1; // skip past ')'
        } else {
          // Not a call, just output the identifier
          result += funcName;
        }
      } else {
        // Any other character
        result += expr[i];
        i++;
      }
    }

    return result;
  }

  /**
   * Extracts the arguments of a function call, respecting:
   *  - nested parentheses
   *  - string literals (single- or double-quoted), so commas inside them are ignored
   */
  function extractArgs(str: string, startIndex: number) {
    const args: string[] = [];
    let current = "";
    let depth = 0;
    let insideString = false;
    let quoteChar = "";
    let i = startIndex + 1;

    while (i < str.length) {
      const char = str[i];

      // Toggle string state
      if ((char === '"' || char === "'") && str[i - 1] !== "\\") {
        if (insideString && char === quoteChar) {
          insideString = false;
          quoteChar = "";
        } else if (!insideString) {
          insideString = true;
          quoteChar = char;
        }
        current += char;
      }
      // Enter nested parentheses
      else if (char === "(" && !insideString) {
        depth++;
        current += char;
      }
      // Close parentheses
      else if (char === ")" && !insideString) {
        if (depth === 0) {
          // end of this function's args
          if (current.trim()) args.push(current.trim());
          break;
        } else {
          depth--;
          current += char;
        }
      }
      // Comma at top-level â€” real parameter separator
      else if (char === "," && depth === 0 && !insideString) {
        args.push(current.trim());
        current = "";
      }
      // Any other character
      else {
        current += char;
      }

      i++;
    }

    return { args, end: i };
  }

  return parseExpression(input);
}
